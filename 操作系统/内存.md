## ch9 内存管理基础
1. 引言
    程序执行前的处理：编译连接和装入。代码编译为目标模块并连接在一起，形成完整装入模块，并将模块装入内存。
    以什么方式装好内存，装在内存的哪里？
    1. 程序连接技术
       - 静态链接       程序运行前将各个模块进行连接。
       - 装入时动态连接  装入内存时候，将目标模块边装边链接
       - 运行时动态链接  在程序执行过程中，需要改目标模块时才能进行链接。

       - I/O 说明空间 地址空间 存储空间
    2. 程序装入技术
       - 绝对装入技术      固定地址再定位 `程序地址空间和内存地址空间是一一对应` 装入过程简单 过于依赖与硬件结构 不适于多道程序系统
       - 可重定位装入技术  添加相应的偏移量，以重定位。 `静态再定位、动态再定位`
         - 静态再定位        `装入程序在程序执行之前进行地址在定位，一旦地址定位完成后，程序执行期间不会发生变化` 定位不能移动 只能连续分配。
         - 动态再定位         `装入内存时，不修改逻辑地址，在访问物理内存前，再实时将逻辑地址转换为物理地址`  
2. 存储管理思想
   - 存储组织结构保存数据在存储技术和cpu寻址技术许可范围内，组织合理的存储结构。
   + 寄存器 (register) 快速缓存(cache) 主存(primary storage) 外存(secondary storage) 
   - 访问速度 容量要求 价格

   - 存储管理目的 充分利用内存，解决程序空间比实际内存空间大的问题。 方便使用
 
   - 存储管理任务 存储分配和回收 存储共享 保护 存储器扩充
   
   - 存储管理方案 
     - `连续内存分配管理` *单一连续存储管理 分区存储管理*   
     - `离散内存分配方式` *分页存储管理 段式存储管理 段页式存储管理方案*   
     - `虚拟存储器`

3. 连续内存分配方式   
   - `单一连续存储管理` *存储位置连续 读取速度快 不适合并行开发任务*
   - `分区管理存储` *内存分为大小相等或不等的分区，每个进程占用一个或几个分区，操作系统占用其中一个分区* ***适用于多道程序系统和分时系统，支持多个程序并发执行*** ==内碎片/外碎片==
     - 固定分区存储管理：内存划分为若干个固定大小的连续分区 。 利用率低
       - 如果是大小不等的区间，多个等待队列。  提高利用率 支持多到处层序 实现简单。但是有内碎片。限制并发执行的程序数目。
     - 动态分区存储管理：动态创建分区。 没有内碎片但是存在外碎片。*注意会先单独创建操作系统*
  
     - 固定大小的分区的利用率会小于动态分配的利用率  外碎片的浪费远远小于内碎片之和。
   
   - 常用分区分配算法 
     - 最先适配算法
       - 算法思想  *按分区先后次序从头查找 ，找到符合要求的第一个分区* **尽可能地利用存储区低地址空闲区，尽量在高地址部分保存较大空闲区，以便之后分配大空闲区**
       - 分配简单 合并空间也较为容易
       - 查找从表首开始 前面分隔空间较少，查找次数较多。
     - 循环最先适配算法
       - 按分区先后次序，从上次分配的分区查找。 空闲分区分布的更加均匀，但较大的空闲分区不容易保留。
     - 最佳适配算法
       - 在所有的满足条件的空闲区中挑选一个最小的分区，是的分配后剩余的块最小。
       - 空闲存储区管理表采用从小到大的顺序结构，可以保留较大的空闲分区。 但是释放空间 合并空闲区的时候较为复杂
     - 最坏适配算法
       - 取所有空闲区中最大的一块。
       - 空闲区由大到小排序。
       - 查找时候的分配算法很快。
       - 但是最后剩余分区会减少，无法运行大程序。
     - 分区算法存在的问题
       - 问题
         - 碎片问题：内存中的空闲块不足以满足分配要求；但是总和满足要求，难以利用造成浪费。 *解决技术：紧凑技术 引出离散分配方式*
         - 分区保护问题：界限寄存器(上下限寄存器) 保护键
     - 内存扩充技术
       - 大程序/小空间
       - 内存扩充 覆盖技术 / 交换技术 
       - 覆盖技术 编程时候 要划分模块和之间的覆盖关系，增加复杂度。 用时间换取空间。
       - 交换技术 整体交换 (进程交换) *解决内存紧张，提高内存利用率* 本部分交换(分页/分段) *支持虚拟存储系统* 
4. 离散分配方式  
   - 页式存储管理
      - 管理思路：用户空间按照逻辑页划分，成为虚页。
         | 页号 | 页内位移量（4k大小页内第几个字节） |
         |:----|:----|
         | 20 | 12 |
      - 划分内存空间 (实页)
      - 页为单位进行分配，并按任务页数多少来分配
      - 逻辑上相邻的页物理上不一定相邻
      - 分页的最后一个是内碎片，页太大可能造成较多碎片的浪费。
   - 进程页表
     - 系统为每一个进程建立一个页表，页表给出逻辑页号和具体内存块号相应的关系。
   - 页式存储管理
     - 页表始址寄存器，页表长度寄存器，联想寄存器器-快表。
     >   没有TLB的地址转换：
         1. CPU发出虚拟地址
         2. MMU访问内存中的页表 ← 慢！需要内存访问
         3. 获取页表项
         4. 计算物理地址
         5. 访问目标物理地址 ← 又一次内存访问
         问题：每次内存访问都需要额外的页表查询，性能降低50%！
      - 两级页表 
      - 可以减少操作系统维护的页表的数量。部分装入的时候可以发挥作用。
   - 段式存储
     - 按照程序自身的逻辑关系划分为若干个程序段。
     - 段名 段号 和段内地址
     - 内存空间划分成为物理段，以段为单位分配内存空间。
   - 进程段表
     - 段号 段的首地址 段的长度
     - 首先适配 最佳适配 最坏适配


## ch10 虚拟内存管理
1. 基本思想
   - 工作过程
     - 程序装入时，将当前需要执行的部分页或者段读入。
     - 程序执行过程中，如果数据不在内存中，执行页中断，调出用不到的程序，调入需要的程序。
     - 引入益处： 可以存放更大的程序（但可能很慢） 更大的用户空间，并发程序，易于开发
     - 特征：内存不连续性，部分交换，大空间。
   - 虚拟存储技术
   - 请求页式管理机制
   - 请求段式管理机制
2. 虚拟页式机制
   - 工作原理
     - 页表结构 页号/终端位/内存块号/外存地址/访问位/修改位
     - *往往采用多级页表，为缩短事件，每一集都可装入到联想存储器中*
   - 页面置换算法
     - 先入先出算法 (FIFO)
       - 选择建立最早的页面置换
       - 性能较差 抖动现象 页中断
     - 最佳算法(OPT)
       - 选择 未来不再使用的 *局部* 或者 在离当前最远位置上出现的 。
     - 最近最少使用页面淘汰算法(LRU)
       - 淘汰最长时间没有被访问的页面。
     - 最近最久未使用算法(LFU)
       - 选择到当前时间为止被访问次数最少的页面被置换
       - 增加计数器
     - 轮转算法(clock)
       - 最近未使用算法 是LRU FIFO 的折中。 使用标签 user
3. 虚拟存储策略
   - 调入策略
     - 用于确定在外存中的页面调入时机
     - 策略：请求调页 (按需调页)
       - 只调入发生缺页时所需的页面。 容易实现，但是开销较大
     - 策略：预调页
       - 发生缺页的时候，一次调入该页以及相邻的页。
       - 提高效率。
   - 页面调入来源
     - 交换区
       - 调入速度快，但是交换空间需要较大。
     - 文件区
       - 未修改的文件直接从文件区中读入，被置换的时候不用调出。
       - 被修改的文件在被置换的时候需要调入到交换区。
   - 调出策略 
     - 确定何时将已经修改的页面调出到外存上。
     - 策略：请求调出
       - 页面被置换的时候才调出。 等待的时间较长。
     - 策略：预调出
       - 页被置换前就调出。 可能造成没必要的开销。

   - 常驻集和工作集策略
     -  常驻集
        -  虚拟页式管理中给进程分配的物理页面数目
           -  固定分配 常驻集大小固定
           -  可变分配 常驻集大小可变
        -  置换范围
           -  局部置换 更容易进行性能分析
           -  全局置换 更为简单，容易实现
     -  工作集
        -  依据进程在过去一段时间内访问的页面来调整常驻集的大小。
   - 负载控制策略
     - 研究内存中驻留多少个并发进程。

