# 算法

### 模拟、枚举

#### 差分数组
1. 定义 
    假设有一个数组 A[n]，差分数组 B[n] 定义为：
    B[1] = A[1]
    B[i] = A[i] - A[i-1] (i > 1)        
    也就是说，B[i] 表示 A[i] 与前一项的差值。
2. 性质
    原数组 A 可以通过差分数组 B 的前缀和还原：
    A[1] = B[1]
    A[2] = B[1] + B[2]
    A[3] = B[1] + B[2] + B[3] 依此类推
    区间修改的优势：

    如果要对原数组 A 的区间 [l,r] 都加上一个值 x ，只需要在差分数组上进行两次操作：
    B[l] += x
    B[r+1] -= x

#### 区间合并 
先将区间按左端点排序
如果当前区间与前一个区间重叠，就合并它们
最后统计合并后的区间中的树的数量

#### 中位数
对于一个奇数长度子序列，要使其中位数为 b，需要：
小于 b 的数字个数等于大于 b 的数字个数，再加上 b 本身，就构成了一个奇数长度子序列。
我们可以将数组中的数分为三类：
小于 b 的数
等于 b 的数
大于 b 的数
使用动态规划来统计满足条件的子序列个数。

####  加权中位数问题
性质：
当需要最小化加权绝对距离时，最佳位置是 加权中位数。
加权中位数的定义是：将所有人数分布到数轴上后，累计人数达到总人数的一半或更大时的位置。

#### 双指针
[双指针【模板】](https://ac.nowcoder.com/acm/contest/20960?from=acdiscuss)  
    思路：滑动窗口,使用双指针维护无重复元素的窗口。
    从头到尾比较，记录每个数字出现的次数和maxlen，并根据次数>1 时候，右移left 即窗口。
[小写字母](https://ac.nowcoder.com/acm/contest/20960/1015)
vector<long long> sum(2 * n + 1, 0);
#### 前缀和
> 环形结构的考虑
``` cpp    
    // 第一遍：计算前n个数的前缀和
    for(int i = 0; i < n; i++) {
        sum[i + 1] = sum[i] + dist[i];
    }
    // 第二遍：复制一遍，处理环形情况
    for(int i = n; i < 2 * n; i++) {
        sum[i + 1] = sum[i] + dist[i - n];
    }
```
#### 质数
```cpp
 bool gcd (long long a,long long b)
 {
     while(b)
     {
        
         long long tmp=b;                   
         b=a%b;
         a=tmp;
     }
     return a==1;
 }
```
#### 位运算的应用
[翻转游戏](https://ac.nowcoder.com/acm/contest/20960/1018)  
将数字利用位来表示.  
[反转游戏(hard)](https://ac.nowcoder.com/acm/contest/20960/1019)  
利用线性代数的思想，将问题转化为一个线性方程组的求解。  
> 高斯消元法

#### 高斯消元法
高斯消元法（Gaussian Elimination）是一种用于求解线性方程组的算法，主要用于将方程组转化为更简单的形式，从而便于求解。它通过一系列的行操作来简化系数矩阵，最终得到解或判断方程组的解的存在性。

 **高斯消元法的基本步骤**

1. **构造增广矩阵**：
   - 将线性方程组的系数矩阵与常数向量合并，形成一个增广矩阵。

2. **行变换**：
   - 通过以下基本操作来简化增广矩阵：
     - 交换两行。
     - 将某一行乘以一个非零常数。
     - 将某一行加到另一行上（可以是乘以一个常数后再加）。

3. **形成阶梯形矩阵**：
   - 目标是将增广矩阵转化为上三角形矩阵（或阶梯形矩阵），即所有主对角线以下的元素为零。

4. **回代求解**：
   - 从最后一行开始，逐步向上代入求解每个变量的值。   

#### 双指针算法

双指针算法是解决子序列匹配问题的经典方法。它的核心思想是通过两个指针分别遍历主字符串 s 和查询字符串 t，按顺序检查 t 的每个字符是否可以在 s 中找到。  
> 双指针算法步骤：  
    初始化两个指针：
    一个指针i用于遍历主字符串 s。
    另一个指针 j 用于遍历查询字符串 t。  
    匹配字符：  
    如果 s[i]==t[j]s[i]==t[j]，说明当前字符匹配，移动 j 指针。无论是否匹配，i 指针始终向前移动。  
    判断结果：  
    如果 j 最终能遍历完整个t（即 j==t.length()j==t.length()），说明 t 是s 的子序列。  
    否则，t 不是 s 的子序列。  
    重复上述过程：  
    对于每个查询字符串 t，重复上述操作。
### 贪心
[图论+优化问题](https://ac.nowcoder.com/acm/contest/20960/1026)   
思路：  
统计横向通道的贡献：对于每一行之间，如果设置一个横向通道，可以切断哪些边。  
统计纵向通道的贡献：对于每一列之间，如果设置一个纵向通道，可以切断哪些边。  
贪心选择通道位置：根据通道的贡献值（切断的边数），选择对切断边贡献最大的k个横向通道和l个纵向通道。  
` 利用各种结构体便于储存 `

### 快速排序